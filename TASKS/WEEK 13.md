<h1 align="center">Pause Day & S.O.L.I.D - Week 13</h1>

## Week goal 🏁

<p>Integrate the backend and frontend of the final project</p>

## Week challenges (Monday) 💻

1. Work on your project

## Week challenges (Tuesday) 💻

1. Work on your project

## Week challenges (Wednesday) 💻

1. Work on your project

## Week challenges (Thursday) 💻

- [x] 1. Check [S.O.L.I.D](https://www.youtube.com/watch?v=2X50sKeBAcQ) video
- [x] 2. Check another [S.O.L.I.D](https://www.youtube.com/watch?v=XzdhzyAukMM) video

![NnqqTSjaZ](https://user-images.githubusercontent.com/108826299/196289188-4750dacb-de67-41d5-aff0-6600326b7019.png)

S.O.L.I.D are a series of standards or recommendations that deal with how to program and how to design and write our systems cleanly and concretely.

The objectives of S.O.L.I.D are several, but the main ones would be to try to make the code more maintainable, that is, to make it very easy to apply changes and fix errors, and also to facilitate the incorporation of new functionalities, making the code more readable and easy to understand.

**Definition of each principle:**

`S` – **Single Responsibility Principle (SRP)**: This principle states that each class should be in charge of a single task within the system; the goal is to get each class to complete a single set and specified task, so that we can make sure they do it successfully.

`O` – **Open/Closed Principle (OCP)**: The formal definition says that a software entity must remain open for its extension but closed for its modification. Basically, what we are trying to achieve with this principle is that the basic functionality of our system is protected and cannot be broken.

`L` – **Liskov Substitution Principle (LSP)**: This principle states that any class that is a child of another class must be able to be used as if it were the same parent, no one who needs to use the parent has to behave differently, and any of its descendants are interacted with.

`I` – **Interface Segregation Principle (ISP)**: This principle states that it is better to have many small classes specialized in one feature than to have one huge class with many features.

`D` – **Dependency Inversion Principle (DIP)**: This principle indicates that high-level modules should not depend on low-level modules both should depend on interfaces, that is, this principle is based on abstraction, concrete implementations should not depend on other concrete implementations but on abstract layers.
